let f : (a : int, b : int) -> int
let g : (a : real, b : real) -> () -> () -> real[]


let omg : (() -> real) -> real := @(a){
    a()
}

g := @(a, b) -> Int {
    return @() {
        return @() {
        }
    }
}

var c := [1, 2, 3, 4, [3], [3]]

var bob : (a : int[], ..., a : Int, ..., b : Int) -> real[] := @(){
}


struct bob {
    a : int, 
    b : real,
    a : bob
}

struct bob {
    omg: Int,
    zomg: Real
}

bob() := 32

if x = 32 {
    println("hey")
}
else if (x = 32) {
    println("derp")
}
else if(ahaha) {
    if(32)
        2 
}
else {
    println(bah)
}

var a := 32

class bob : tom {
    
    _() {

    }

    ~_() {

    }

    ~_() {
    }

    {[]}(a: Double) {

    }

    var a : int

    - var a : int
    + var b : int
}

let bob := @(x, y){x + y}


let b := @(x : real , y : real) {
    x + y
}



