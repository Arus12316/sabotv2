
let f : (a : int, b : int) -> int
let g : (a : real, b : real) -> () -> () -> real[]

let omg : (() -> real) -> real := @(a){
    a()
}

g := @(a, b) -> Int {
    return @() {
        return @() {
        }
    }
}

var c := [1, 2, 3, 4, [3], [3]]

var bob : (a : int[], ..., a : Int, ..., b : Int) -> real[] := @(){
}

1 + 3 + 4 + 5*3*3*3+4

struct bob {
    a : int, 
    b : real,
    a : bob
}

struct bob {
    omg: Int,
    zomg: Real
}

bob() := 32

if x = 32 {
    println("hey")
}
else if (x = 32) {
    println("derp")
}
else if(ahaha) {
    if(32)
        2 
}
else {
    println(bah)
}

var a := 32

let f := @(a: Int8) -> Int {
    if(a = 32) {
        a := 33
    }
    a
}

let f := @(a: Int8) -> Double {
}

class bob : tom {
    let a: Int
    let b: Int
    let c: String

    let c: String[]

    _() {
        _.a := 32
        _.b := 33
        _.c := "hello world"
        if _.a = 23 {
            _.a := 33
            _.b := _.a * 32 * 32
        }
        __()
    }

    ~_(a: Int, b: Int) {

    }

    ~_() {
    }

    {*=}(a: Double) {
        _.a ^ a
        _.a XOR 32
    }

    {^}(a: Double) {
        _.a *= a
    }

    {>>}(a: Double) {

    }

    { >>* }() {

    }

    var a : int

    - var a : int
    + var b : int
}

let bob := @(x, y){x + y}

let b := @(x : real , y : real) {
    x + y
}



